//! The RLFuzzer schedulers are a family of schedulers that use the bandit
//! algorithm to get a better result of corpus selecting.

use alloc::{borrow::ToOwned, vec::Vec};
use core::marker::PhantomData;

use serde::{Deserialize, Serialize};

use super::testcase_score::{
    GeneratedTestcaseScore, SeedSelectionTestcaseScore, SeedTimeTestcaseScore,
};
use crate::{
    corpus::{testcase::RLFuzzTestcaseMetaData, Corpus},
    inputs::UsesInput,
    schedulers::{Scheduler, TestcaseScore},
    state::{HasCorpus, HasMetadata, UsesState},
    Error,
};

/// Compute probability distributions over a corpus.
pub trait TestcaseDistribution<S>
where
    S: HasCorpus + HasMetadata,
{
    /// Compute the score of all testcase.
    fn compute(state: &S) -> Result<Vec<Vec<f64>>, Error>;
}

/// Combine two [`TestcaseDistribution`]s together.
#[derive(Debug, Clone)]
pub struct TestcaseDistributionCombiner<S, F, G>
where
    S: HasCorpus + HasMetadata,
    F: TestcaseDistribution<S>,
    G: TestcaseDistribution<S>,
{
    phantom: PhantomData<(S, F, G)>,
}

impl<S, F, G> TestcaseDistribution<S> for TestcaseDistributionCombiner<S, F, G>
where
    S: HasCorpus + HasMetadata,
    F: TestcaseDistribution<S>,
    G: TestcaseDistribution<S>,
{
    fn compute(state: &S) -> Result<Vec<Vec<f64>>, Error> {
        let mut metrics = F::compute(state)?;
        metrics.extend(G::compute(state)?);
        Ok(metrics)
    }
}

/// Number of times a seed being selected.
#[derive(Debug, Clone)]
pub struct SeedSelectionDistribution<S> {
    phantom: PhantomData<S>,
}

impl<S> TestcaseDistribution<S> for SeedSelectionDistribution<S>
where
    S: HasCorpus + HasMetadata,
{
    fn compute(state: &S) -> Result<Vec<Vec<f64>>, Error> {
        let mut metrics = Vec::with_capacity(state.corpus().count());
        for idx in 0..state.corpus().count() {
            let entry = state.corpus().get(idx)?.borrow();
            metrics.push(*entry.executions() as f64);
        }
        let sum = metrics.iter().sum::<f64>();
        Ok(vec![metrics.into_iter().map(|x| x / sum).collect()])
    }
}

/// Number of inputs generated by fuzzing seed
#[derive(Debug, Clone)]
pub struct SeedGeneratedDistribution<S> {
    phantom: PhantomData<S>,
}

impl<S> TestcaseDistribution<S> for SeedGeneratedDistribution<S>
where
    S: HasCorpus + HasMetadata,
{
    fn compute(state: &S) -> Result<Vec<Vec<f64>>, Error> {
        let mut metrics = Vec::with_capacity(state.corpus().count());
        for idx in 0..state.corpus().count() {
            let entry = state.corpus().get(idx)?.borrow();
            if entry.has_metadata::<RLFuzzTestcaseMetaData>() {
                let rlmeta = entry.metadata().get::<RLFuzzTestcaseMetaData>().unwrap();
                println!("generated: {}", rlmeta.generated());
                metrics.push(rlmeta.generated() as f64)
            } else {
                metrics.push(0 as f64)
            }
        }
        let sum = metrics.iter().sum::<f64>();
        Ok(vec![metrics.into_iter().map(|x| x / sum).collect()])
    }
}

/// Temporary type used for testing, combine all distributions together.
//  TODO: implement a macro for combining distributions.
pub type CombinedDistribution<S> =
    TestcaseDistributionCombiner<S, SeedSelectionDistribution<S>, SeedGeneratedDistribution<S>>;

/// The metadata used in bendit algorithm
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct BenditMetadata {
    /// weight for different arms
    weights: Vec<f64>,
}

crate::impl_serdeany!(BenditMetadata);

/// Use the bandit algorithm to get a better result of corpus selecting.
#[derive(Debug, Clone)]
pub struct RLScheduler<S, F> {
    phantom: PhantomData<(S, F)>,
}

impl<S, F> UsesState for RLScheduler<S, F>
where
    S: UsesInput,
{
    type State = S;
}

impl<S, F> Scheduler for RLScheduler<S, F>
where
    S: HasCorpus + HasMetadata,
    F: TestcaseScore<Self::State>,
{
    /// Gets the next entry. Every time this function is called, scores of all testcases will be updated.
    fn next(&self, state: &mut Self::State) -> Result<usize, Error> {
        let corpus_num = state.corpus().count();
        if corpus_num == 0 {
            Err(Error::empty("No entries in corpus".to_owned()))
        } else {
            let mut min_score = f64::MAX;
            let mut id = match state.corpus().current() {
                Some(cur) => {
                    if *cur + 1 >= state.corpus().count() {
                        0
                    } else {
                        *cur + 1
                    }
                }
                None => 0,
            };
            // find the seed with smallest score.
            for idx in 0..corpus_num {
                let mut entry = state.corpus().get(idx).unwrap().borrow_mut();
                if let Ok(score) = F::compute(&mut *entry, state) {
                    println!("ðŸ’¯ {}, {}", idx, score);
                    if score < min_score {
                        min_score = score;
                        id = idx;
                    }
                }
            }
            *state.corpus_mut().current_mut() = Some(id);
            println!("ðŸ”¥ {} selected", id);
            Ok(id)
        }
    }
}

impl<S, F> RLScheduler<S, F>
where
    S: HasCorpus + HasMetadata,
    F: TestcaseScore<S>,
{
    /// Creates a new [`RLScheduler`]
    #[must_use]
    pub fn new() -> Self {
        Self {
            phantom: PhantomData,
        }
    }
}

/// AFLFast-like scheduler, minimize s(i)
pub type SelectionRLScheduler<S> = RLScheduler<S, SeedSelectionTestcaseScore<S>>;

/// BlackboxFuzz-like scheduler, minimize N(i)
pub type GeneratedRLScheduler<S> = RLScheduler<S, GeneratedTestcaseScore<S>>;

/// BlackboxFuzz-like scheduler, minimize t(i)
pub type TotalTimeRLScheduler<S> = RLScheduler<S, SeedTimeTestcaseScore<S>>;
